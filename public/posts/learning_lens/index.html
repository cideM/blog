<p>I often hate Haskell but at the same time I can't stop learning it because it would feel like giving up. Learning new things in Haskell is often one of the most frustrating experiences I can think of. I stare at code that seems completely impenetrable and the category theory jargon, together with super descriptive single letter variables, feels like a concerted effort at obfuscation. Use it in papers, when discussing among equals, but not in tutorials. You've invested effort into creating a tutorial, why not go the extra mile and use descriptive names for us sub-9000 IQ folks. /rant</p>
<p>I'll use this post as a dumping ground for random thoughts while trying to learn lenses. I apologize for the language.</p>
<h1>Naming</h1>
<p>I'm really grateful that stuff like <a href="https://artyom.me/lens-over-tea-1">the "lens over tea" writeup</a> exists. Really, I mean it. Yet at the same time...</p>
<pre><code class="language-haskell">data Storey x f a = Storey x (f a) -- ^ f a is functor a
  deriving Show


fmap f        (x, a) =     (x,) $      f a
fmap f (Storey x  a) = Storey x $ fmap f a
-- ^ f a is a function applied to a. a is (f a) from above.
</code></pre>
<p>The two code snippets are about 2 viewport heights apart (I added the comments). Stuff like this puts me in instant rage mode. It's like someone is stabbing me with a tiny knife - it won't kill me but it still inflicts a lot of pain on a constant basis. Everytime I see an <code>f</code> I need to check if it's a function or a functor. It's especially confusing if, as here, what was called <code>f a</code> (functor) is now <code>a</code>, and <code>f</code> is just a function.</p>
<p>Occasionally I see people refer to <code>f a</code> from a type signature as <code>fa</code> in data land. That's nice. It makes the connection between both very clear, while still being general and abstract. Let's try again:</p>
<pre><code class="language-haskell">data Storey x f a = Storey x (f a)
  deriving Show


fmap fn        (x, a ) =     (x,) $      fn  a
fmap fn (Storey x  fa) = Storey x $ fmap fn fa
</code></pre>
<p>This makes the connection between <code>f a</code> from the data declaration and <code>fa</code> from the function clear. It also makes it obvious that <code>fn</code> is something new, something that has nothing to do with the data declaration.</p>
<p>I don't care if every PhD-holding Haskell-writing rocket scientist immediately knows and understands that the convention is for <code>f</code> to be functor in types and function everywhere else. And I realize that the linked article isn't even supposed to be a tutorial and that the author said that</p>
<blockquote>
<p>this post is an exploration more than an explanation, so don't expect the text to be structured the way normal blog posts are. If I knew how to structure it all in such a way that it wouldn't be a tangled braindump, I would've done that.</p>
</blockquote>
<p>I'm using it as an example for something that is pervasive throughout Haskell.
In tutorials, in SO posts, on reddit. I know everyone means well and I respect
that and am grateful. But this post is what learning Haskell <em>often feels like
<strong>to me</strong></em>.</p>
<h2>Success Is Commemorated, Failure Merely Remembered</h2>
<p>Hey, at least I'll be remembered :|! The post eventually includes this section, where you're supposed to test your understanding. Which, by the way, is amazing! Tutorials (sorry I'll just call it tutorial from now on) without exercises are useless.</p>
<pre><code class="language-haskell">{-# LANGUAGE RankNTypes, TupleSections #-}

import Control.Applicative

type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
type Lens' s a = Lens s s a a

-- _1 :: Functor f => (a -> f b) -> (a, x) -> f (b, x)
_1 :: Lens (a, x) (b, x) a b
_1 = _
</code></pre>
<p>So let's see. I could get the <code>a</code> out of the tuple and apply it to the modifier function. That gives me <code>f b</code>, or a functor with a <code>b</code>. Then I could map a function over that result (functor), and turn the inner <code>b</code> into <code>(b, x)</code>. It would work, and it's 100% not what I'm supposed to do (BIG PLOT TWIST AHEAD!).</p>
<pre><code class="language-haskell">_1 modifierFn (first, second) =
  let result = modifierFn first
   in fmap (, second) result
</code></pre>
<p>or</p>
<pre><code class="language-haskell">_1 modifierFn (first, second) = (, second) &#x3C;$> modifierFn first
</code></pre>
<p>The type checker is happy, at least that I got right. The tuple section came from hlint by the way. I do know that it's a thing and it's not hard to use but I put that in the "stabbing with a tiny knife" category. Layers of syntactic sugar eventually add up to obscure code (insert quote about Golang here).</p>
<p>The above function doesn't feel right, because I'm sure there's a clever way to make it <del>less explicit and harder to understand</del> more idiomatic.</p>
<p>After staring at it for like 2 hours or so and eventually trying random code with <code>Compose</code> I looked at Github repos. It seems no one is using <code>Compose</code> for <code>_1</code> and <code>_2</code> so I won't either. Moving on?</p>
<pre><code class="language-haskell">choosing l1 l2 fn source =
  case source of
    Left s1  -> Left &#x3C;$> l1 fn s1
    Right s2 -> Right &#x3C;$> l2 fn s2
</code></pre>
<p>This is the solution to <code>choosing</code>. It has an obvious implementation which follows from the third sphere and is left as an exercise to the reader. Just kidding. Took me a while. Sometimes I feel like I need to zone out and squint to grok Haskell. If I stare too hard and focus on only a tiny part of a function the bigger picture often eludes me. Or something like that? Also expand type synonyms, specialize types and write down your intermediate steps. Otherwise you'll constantly lose track and have to start again.</p>
<p>In this case the expanded signature is long. Really long. But by this time I felt like I was starting to maybe get a hang of at least some things. A lens is a modifier function and a source. (That's what the author was getting at with the whole setter is the getter thing I think). So when you see Lens, ignore the types for a moment and just think of a function, that takes a modifier and a value. That's a lens. It's a function with 2 arguments.</p>
<p>In this case, the value (called source in my snippet) can be <code>Left</code> or <code>Right</code>. So we start by checking which one it is. If you don't know how to get started on this one, I'd say always start with the <code>source</code>. And because <code>choosing</code> <em>is a Lens</em> and a Lens is a function taking <em>two arguments</em> we just start our implementation by checking its second argument, the source, from where everything else follows eventually.</p>
<p>Honestly I don't know if the above is correct. It's so simple and helps me so much that there's no way the lens documentation doesn't mention this in font size 200 on the front page if it were true. Although looking at how <code>Lens</code> is <a href="http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Type.html#t:Lens">defined in the actual package</a> it seems true enough. Yet they say that</p>
<blockquote>
<p>Lens' bigger smaller</p>
</blockquote>
<p>and</p>
<p><code>type Lens' a b = forall f . Functor f => (b -> f b) -> (a -> f a)</code></p>
<p>or simpler</p>
<p><code>type Lens' a b = (b -> f b) -> (a -> f a)</code></p>
<p>The way the parentheses are placed here is really confusing. It looks like a <code>Lens'</code> is just a function taking two arguments without ever returning anythin. Of course the parentheses are also irrelevant and so it does return an <code>f a</code>. But that's somewhat like what I ranted about in "Naming", that the way things look definitely affects my understanding since I often judge a cover by a book, so to speak, since I am not yet experienced enough to immediately look past that cover.</p>
<p>I would say:</p>
<blockquote>
<p>What is a lens?</p>
<p>A lens is a function taking two arguments: a modifier function, and a source value.</p>
</blockquote>
<p>The word "modifier" is probably wrong and misses something but whatever.</p>
<p>For this snippet</p>
<pre><code class="language-haskell">choosing l1 l2 fn source =
  case source of
    Left s1  -> Left &#x3C;$> l1 fn s1
    Right s2 -> Right &#x3C;$> l2 fn s2
</code></pre>
<p>we pass the modifier function to the first or second lens (depending on the <code>Either</code>). Now that lens was applied to its first argument, and the only thing left to do (in fact that's the only thing you can do), is apply it to its second argument - the source. We then get back an <code>f a</code>. <strong>But the return type of Lens is <code>f target</code></strong>. The type signature of <code>choosing</code> is</p>
<pre><code class="language-haskell">choosing ::
     Lens s1 t1 a b -> Lens s2 t2 a b -> Lens (Either s1 s2) (Either t1 t2) a b
--                                                            ^^^^^ target

type Lens s t a b
   = forall f. Functor f =>
                 (a -> f b) -> s -> f t

-- so specialized

type SpecializedLens
   forall f. Functor f =>
                (a -> f b) -> (Either s1 s2) -> f (Either t1 t2)
</code></pre>
<p>Because of the return type <code>f (Either t1 t2)</code> applying <code>l2 fn</code> to <code>s2</code> is not enough. That's merely running a single Lens which gives a functor one level deep, but we need two levels. <code>Left &#x3C;$> l1 fn s1</code> does that. GG.</p>
<h2>All is Vain ðŸ’£</h2>
<p>Wow. The next one made me question pursuing Haskell any further. I had to check Github, realized that I didn't understand the solutions with <code>liftA2</code> and I didn't even try to understand <code>&#x26;&#x26;&#x26;</code>. That meant I had to actually solve it and I needed to do it with as simple as code as possible. So pretty much the opposite of the bonus points.</p>
<pre><code class="language-haskell">-- Modify the target of a lens and return the result. (Bonus points if you
-- do it without lambdas and defining new functions. There's also a hint
-- before the end of the section, so don't scroll if you don't want it.)
(&#x3C;%~) :: Lens s t a b -> (a -> b) -> s -> (b, t)
(&#x3C;%~) l f s = _
</code></pre>
<p>Frankly I didn't know where to start. <code>a -> b</code> is not compatible with <code>a -> f b</code>. That lead me off on a tangent to find a function that helps with that until an SO post mentioned the obvious: <code>a -> f a</code> is a type constructor. Like <code>\x -> Just x</code>. The function is supposed to return a tuple so the functor we'll be using is <code>(,)</code> (which has a functor instance).</p>
<p>That was at least one step forward.</p>
<p>I also knew that I somehow needed to take the function just called <code>f</code> in the snippet <em>taken from the tutorial</em> and apply the lens <code>l</code> to that function and the source <code>s</code>. I need to do <code>l f' s</code>, and somehow turn the given <code>f</code> into my <code>f'</code>.</p>
<p>A lens takes an <code>a -> f b</code> but I only had <code>a -> b</code>. I've read and written enough Haskell to know that this smells like <code>lift</code>. But e.g., <code>liftA2</code> makes an unlifted function <code>a -> b -> c</code> work on <code>f a</code> and <code>f b</code> and <code>f c</code>. I however had an <code>a</code> as an input but needed an <code>f something</code> as an output. :thinking: And I also know that <code>a -> f a</code> is simply a constructor. Something something <code>(,)</code> and <code>lift</code>?</p>
<p>I took the low road and reverse engineered the <code>liftA2</code> solutions out there. I arrived at</p>
<pre><code class="language-haskell">(&#x3C;%~) lens fn source = lens modifierFn source
  where
    modifierFn x = ((,) . fn) x (fn x)
</code></pre>
<p>This is nice for people like me (or just me). It's very clear how this leads to <code>(b,t)</code>. It's very explicity and verbose. So how do I get from this to understand the <code>liftA2</code> solutions? I looked into the functor chapter from Haskell from First Principle again and immediately realized that I need to go through the entire book again (I skimmed the chapters one strictess and exceptions and I apparently never learned or forgot a lot of other stuff). More importantly though, I looked into the <strong>functor instance for functions</strong>.</p>
<p>Recap: I have an <code>a -> b</code> and the <code>b</code> needs to be put into a functor (here a tuple). I can achieve that by <code>fmap</code>ping the functor over the function. The functor instance for functions is actually just composition. So <code>fmap (,) fn</code> is the same as <code>(,) . fn</code> which is exactly what I did in the above snippet. Let's see what the snippet looks like, if we extract the <code>(,) . fn</code> part into its own function.</p>
<pre><code class="language-haskell">(&#x3C;%~) lens fn source = lens modifierFn source
  where
    modifierFn x = helper x (fn x)
    helper = (,) . fn
</code></pre>
<p>That looked like something rather common and after looking at several different resources I eventually came upon the definition of <code>&#x3C;*></code> for functions.</p>
<pre><code class="language-haskell">instance Applicative ((->) r) where
    f &#x3C;*> g = \x -> f x (g x)
</code></pre>
<p>What a surprise. The <code>modifierFn</code> I ended up with after extracting <code>helper</code> looks exactly like <code>&#x3C;*></code>. So</p>
<pre><code class="language-haskell">(&#x3C;%~) lens fn source = lens modifierFn source
  where
    -- vvv--- same as --->>> modifierFn x = helper x (fn x)
    modifierFn = helper &#x3C;*> fn
    helper = (,) . fn
</code></pre>
<p>I then looked at the source for <code>liftA2</code> again, which is <code>liftA2 f x = (&#x3C;*>) (fmap f x)</code>. The last argument was eta reduced away, so it's actually (with some renaming) <code>liftA2 f fa fb = (&#x3C;*>) (fmap f fa) fb</code>. So... let's take the <code>liftA2</code> solution and compare it to what I've now learned (or relearned).</p>
<pre><code class="language-haskell">(&#x3C;%~) lens fn = lens (liftA2 (,) fn fn)
-- ^                          f  fa fb &#x3C;-- in the above paragraph
-- Expanded
(&#x3C;%~) lens fn = lens $ (&#x3C;*>) (fmap (,) fn) fn
(&#x3C;%~) lens fn = lens $ (&#x3C;*>) ((,) . fn) fn
(&#x3C;%~) lens fn = lens $ \x -> ((,) . fn) x (fn x)
</code></pre>
<p>And there you have it. At the bottom is my verbose approach, and then we "just" extract the patterns for which Haskell already has typeclasses.</p>
<h1>Recap</h1>
<p>My fundamental problem with the exercises was that I was looking for a clever solution right from the start. But I don't know enough about Haskell, nor anything about category theory, to make the mental leap from type signature to implementation that does it all in a one-liner using existing abstractions.</p>
<p>What I should have done in all cases is to just try to write a verbose, manual solution and then see if it can be reduced further. The author of "Lens over Tea" even offers the following solutions:</p>
<blockquote>
<p>But the right thing to do is one of these:</p>
</blockquote>
<pre><code class="language-haskell">(&#x3C;%~) l f = l (\x -> let fx = f x in (fx, fx))

(&#x3C;%~) l f = l $ (\t -> (t, t)) . f
</code></pre>
<p>That's really easy to understand (and only computes <code>f x</code> once). But I don't know if this is considered idiomatic Haskell. And that's one of my major issues with this language right now. I have no idea what kind of clever is too clever and what kind of verbose is too verbose.</p>
